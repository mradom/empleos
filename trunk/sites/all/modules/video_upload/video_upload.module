<?php

// $Id: video_upload.module,v 1.1.2.13 2008/07/09 15:57:50 jhedstrom Exp $

/**
 * @file
 *   video upload module
 * @todo
 *   See TODO.txt, and inline todo comments
 */


// Include Zend GData interface API
include_once 'zend_gdata.inc';

// The YouTube base url for embedding video
define('VIDEO_UPLOAD_YOUTUBE_EMBED_URL', 'http://www.youtube.com/v');
// YouTube thumbnail (0) base url
define('VIDEO_UPLOAD_YOUTUBE_THUMB_URL', 'http://img.youtube.com/vi');
// The normal feed base
define('VIDEO_UPLOAD_YOUTUBE_FEED_BASE', 'http://gdata.youtube.com/feeds/videos');
// The feed for an authenticated user that shows all videos
define('VIDEO_UPLOAD_YOUTUBE_DEFAULT_USER_FEED', 'http://gdata.youtube.com/feeds/api/users/default/uploads');

// Video status levels
define('VIDEO_UPLOAD_STATUS_ORPHANED', -3);
define('VIDEO_UPLOAD_STATUS_DELETE', -2);
define('VIDEO_UPLOAD_STATUS_BAD', -1);
define('VIDEO_UPLOAD_STATUS_UNKNOWN', 0);
define('VIDEO_UPLOAD_STATUS_OK', 1);
define('VIDEO_UPLOAD_STATUS_OK_SYNCED', 2);

// Video synchronization
define('VIDEO_UPLOAD_SYNC_NONE', 0);
define('VIDEO_UPLOAD_SYNC', 1);
define('VIDEO_UPLOAD_SYNC_APPEND', 2);


/**
 * Implementation of hook_simpletest()
 *
 * Gather available unit tests directory includes tests for
 * video_upload.module
 */
function video_upload_simpletest() {
  $dir = drupal_get_path('module', 'video_upload') . '/tests';
  $tests = file_scan_directory($dir, '\.test$');
  return array_keys($tests);
}

/**
 * Implementation of hook_perm()
 */
function video_upload_perm() {
  return array('administer video upload settings', 'administer uploaded videos');
}

/**
 * Implementation of hook_menu()
 */
function video_upload_menu($may_cache) {
  if ($may_cache) {
    $items[] = array(
      'path' => 'admin/settings/video-upload',
      'title' => t('Video Upload Settings'),
      'callback' => 'drupal_get_form',
      'callback arguments' => array('_video_upload_admin_settings_form'),
      'access' => user_access('administer video upload settings'),
   );
    // the js callback that youtube redirects to
    $items[] = array(
      'path' => 'video-upload/js',
      'callback' => 'video_upload_js',
      'access' => TRUE,
      'type' => MENU_CALLBACK,
    );
    // admin page for removing stranded videos (not attached to a node)
    $items[] = array(
      'path' => 'admin/content/video-upload',
      'title' => t('Manage Video Uploads'),
      'callback' => 'video_upload_admin_video',
      'access' => user_access('administer uploaded videos'),
      'type' => MENU_NORMAL_ITEM,
    );
  }
  return $items;
}

/**
 * Implementation of hook_form_alter()
 */
function video_upload_form_alter($form_id, &$form) {
  switch ($form_id) {
    case 'search_theme_form' :
      // For some reason, the id is set to edit-submit, which causes problems
      // on a node-edit form, since the jquery selector fails once there are
      // two items with id #edit-submit.
      // @todo submit a patch to core to fix this
      $form['submit']['#id'] = 'search-submit';
      break;
    default :
  }
}


/**
 * Implementation of hook_keys_service()
 * @todo
 *   This should integrate with the service module
 */
function video_upload_keys_service() {
  return array(
    'video_upload_youtube' => array(
      'name' => t('Video Upload: YouTube'),
      'description' => t('YouTube/Gdata Developer Key'),
    ),
    // add other providers here
  );
}

/**
 * Implementation of hook_field_info()
 */
function video_upload_field_info() {
  return array(
    'video_upload' => array('label' => t('Video Upload')),
  );
}

/**
 * Implementation of hook_field_settings()
 */
function video_upload_field_settings($op, $field) {
  switch ($op) {
    case 'form':
      $form = array();
      return $form;
    
    case 'validate':
      return true;

    case 'save':
      return;

    case 'database columns':
      $columns = array(
        // the youtube ID
        'id' => array(
          'type' => 'varchar(32)',
          'default' => "''",
          'not null' => TRUE,
        ),
        // youtube status
        'status' => array(
          'type' => 'int',
          'default' => '0',
          'not null' => TRUE,
          'sortable' => TRUE,
        ),
        // time of status update
        'status_ts' => array(
          'type' => 'int(11)',
          'not null' => TRUE,
          'sortable' => TRUE,
          'default' => '0',
        ),
        // file id, if being stored locally for direct upload
        'fid' => array(
          'type' => 'int',
          'not null' => TRUE,
          'default' => '0',
        ),
      );
      return $columns;

    case 'filters':
      // @todo implement a filter here to allow the status column to be
      //       filtered on in views
      return array();
  }
}

/**
 *  Implementation of hook_field()
 */
function video_upload_field($op, &$node, $field, &$items, $teaser, $page) {
  switch ($op) {
    case 'load' :
      /*
      if (!count($items)) {
        return;
      }
      */
      break;
    case 'view':
      /*
      $context = $teaser ? 'teaser' : 'full';
      $formatter = isset($field['display_settings'][$context]['format']) ? $field['display_settings'][$context]['format'] : 'default';
      foreach ($items as $delta => $item) {
        $items[$delta]['view'] = content_format($field, $item, $formatter, $node);
      }
      return theme('field', $node, $field, $items, $teaser, $page);
      */
      break;
    case 'validate':
        
        return;
    case 'delete' :
      return _video_upload_delete($items, $field);
  }
}

/**
 * Implementation of hook_widget_info()
 */
function video_upload_widget_info() {
  return array(
    'video_upload' => array(
      'label' => t('Upload/Edit/Display Video'),
      'field types' => array('video_upload'),
    ),
  );
}

/**
 * Implementation of hook_widget_settings()
 *
 * @fixme
 *   allow for more token types other than users
 */
function video_upload_widget_settings($op, $widget) {
  switch ($op) {
    case 'callbacks':
      // disable the default value part of the form
      return array('default value' => CONTENT_CALLBACK_CUSTOM);

    case 'form':
      $form = array();
      // allowed file extensions
      $form['file_extensions'] = array(
        '#type' => 'textfield',
        '#title' => t('Allowed upload file extensions.'),
        '#default_value' => $widget['file_extensions'] ? $widget['file_extensions'] : 'mov avi mpg mpeg',
        '#size' => 64,
        '#maxlength' => 64,
        '#description' => t('Video filename extenstions allowed by YouTube. Seperate extensions with a space and do not include the leading dot.')
      );

      $form['use_browser_upload_method'] = array(
        '#type' => 'hidden',
        '#value' => true,

        // @todo once the direct upload method is working, this option
        //       should be enabled.

        // '#type' => 'checkbox',
        // '#title' => t('Use Browser Upload Method'),
        // '#default_value' => isset($widget['use_browser_upload_method']) ? $widget['use_browser_upload_method'] : true,
        // '#description' => t('The <a href="!url">Browser Upload Method</a> sends video files directly to YouTube, instead of touching the Drupal server. This saves on storage and bandwidth', array('!url' => url('http://code.google.com/apis/youtube/developers_guide_php.html#BrowserUpload'))),
      );

      // maintenance
      $form['auto_delete_rejected_videos'] = array(
        '#type' => 'checkbox',
        '#title' => t('Auto-delete rejected videos from account'),
        '#description' => t('When videos are rejected, use cron to automatically remove them from YouTube'),
        '#default_value' => isset($widget['auto_delete_rejected_videos']) ? $widget['auto_delete_rejected_videos'] : FALSE,
      );

      // width and height
      $form['display'] = array(
        '#type' => 'fieldset',
        '#title' => t('Display Options'),
        '#tree' => TRUE,
        '#collapsible' => TRUE,
      );
      $form['display']['default_width'] = array(
        '#type' => 'textfield',
        '#title' => t('Default/Large Width'),
        '#required' => TRUE,
        '#default_value' => $widget['display']['default_width'] ? $widget['display']['default_width'] : '425',
        '#description' => t('The width for the default (large) player'),
      );
      $form['display']['default_height'] = array(
        '#type' => 'textfield',
        '#title' => t('Default/Large Height'),
        '#required' => TRUE,
        '#default_value' => $widget['display']['default_height'] ? $widget['display']['default_height'] : '355',
        '#description' => t('The height for the default (large) player'),
      );
      $form['display']['small_width'] = array(
        '#type' => 'textfield',
        '#title' => t('Small Width'),
        '#required' => TRUE,
        '#default_value' => $widget['display']['small_width'] ? $widget['display']['small_width'] : '225',
        '#description' => t('The width for the small player'),
      );
      $form['display']['small_height'] = array(
        '#type' => 'textfield',
        '#title' => t('Small Height'),
        '#required' => TRUE,
        '#default_value' => $widget['display']['small_height'] ? $widget['display']['small_height'] : '187',
        '#description' => t('The height for the small player'),
      );
      $form['display']['thumb_width'] = array(
        '#type' => 'textfield',
        '#title' => t('Thumbnail Width'),
        '#default_value' => $widget['display']['thumb_width'] ? $widget['display']['thumb_width'] : '120',
      );
      $form['display']['thumb_height'] = array(
        '#type' => 'textfield',
        '#title' => t('Thumbnail Height'),
        '#default_value' => $widget['display']['thumb_height'] ? $widget['display']['thumb_height'] : '90',
      );
      $form['display']['related_videos'] = array(
        '#type' => 'checkbox',
        '#title' => t('Show related videos'),
        '#default_value' => $widget['display']['related_videos'],
        '#description' => t('Show related videos in the player after the video has finished.'),
      );
      $form['display']['autoplay'] = array(
        '#type' => 'checkbox',
        '#title' => t('Auto-play video on page load'),
        '#default_value' => $widget['display']['autoplay'],
      );

      // default title pattern
      $form['default_title'] = array(
        '#type' => 'textfield',
        '#title' => t('Default Video Title'),
        '#default_value' => $widget['default_title'],
        '#size' => 64,
        '#maxlength' => 255,
        '#description' => t('Since the videos are initially uploaded prior to node creation, they must contain a default title. This title will only be visible on YouTube proper, and will be updated once the node is saved, and the video has been processed.'),
      );
      if (module_exists('token')) {
        $form['default_title']['#description'] .= ' '. t('<br />The following tokens can be used in the default title');
        $form['default_title']['#suffix'] = theme('fieldset', array('#children' => theme('token_help', 'user'), '#collapsed' => TRUE, '#collapsible' => TRUE, '#title' => t('Tokens')));
      }

      // default title synchronization
      $form['default_title_sync'] = array(
        '#type' => 'radios',
        '#title' => t('Default Video Title Synchronization'),
        '#description' => t('The <em>Video Upload module</em> will attempt to synchronize data with %provider, these options determine the extent of such synchronization', array('%provider' => 'YouTube')),
        '#options' => array(
          VIDEO_UPLOAD_SYNC => t('Synchronize (overwrite default)'), 
          VIDEO_UPLOAD_SYNC_NONE => t('Don\'t Synchronize (keep default)'),
          VIDEO_UPLOAD_SYNC_APPEND => t('Append node title to default'),
        ),
        '#default_value' => isset($widget['default_title_sync']) ? $widget['default_title_sync'] : VIDEO_UPLOAD_SYNC,
        '#required' => TRUE,
      );

      // default description
      $form['default_description'] = array(
        '#type' => 'textarea',
        '#title' => t('Default video description'),
        '#default_value' => $widget['default_description'],
        '#description' => t('Since the videos are initially uploaded prior to node creation, they can contain a default description. This description will only be visible on YouTube proper, and will be updated with the node teaser once the node is saved and the video has been processed.'),
      );
      if (module_exists('token')) {
        $form['default_description']['#description'] .= t('<br />The following tokens can be used in the default description');
        $form['default_description']['#suffix'] = theme('fieldset', array('#children' => theme('token_help'), '#collapsed' => TRUE, '#collapsible' => TRUE, '#title' => t('Tokens')));
      }

      // default description synchronization
      $form['default_description_sync'] = array(
        '#type' => 'radios',
        '#title' => t('Default Video Description Synchronization'),
        '#description' => t('The <em>Video Upload module</em> will attempt to synchronize data with %provider, these options determine the extent of such synchronization', array('%provider' => 'YouTube')),
        '#options' => array(
          VIDEO_UPLOAD_SYNC => t('Synchronize (overwrite default)'), 
          VIDEO_UPLOAD_SYNC_NONE => t('Don\'t Synchronize (keep default)'), 
          VIDEO_UPLOAD_SYNC_APPEND => t('Append Description to default')
        ),
        '#default_value' => isset($widget['default_description_sync']) ? $widget['default_description_sync'] : VIDEO_UPLOAD_SYNC_APPEND,
        '#required' => TRUE,
      );

      // keywords
      // @todo - some input validation
      $form['default_keywords'] = array(
        '#type' => 'textfield',
        '#title' => t('Default YouTube keywords'),
        '#required' => TRUE,
        '#description' => t('Comma-separated list of keywords (no white space allowed in keywords).<br /><br />Since the videos are initially uploaded prior to node creation, they must contain a default set of keywords. These keywords will only be visible on YouTube proper, and will be updated with taxonomy terms (if in use on this content type) once the node is saved and the video has been processed.'),
        '#default_value' => $widget['default_keywords'],
      );
      // default keyword synchronization
      $form['default_keyword_sync'] = array(
        '#type' => 'radios',
        '#title' => t('Default Video Keyword Synchronization'),
        '#description' => t('The <em>Video Upload module</em> will attempt to synchronize data with %provider, these options determine the extent of such synchronization', array('%provider' => 'YouTube')),
        '#options' => array(
          VIDEO_UPLOAD_SYNC => t('Synchronize (overwrite default)'), 
          VIDEO_UPLOAD_SYNC_NONE => t('Don\'t Synchronize (keep default)'), 
          VIDEO_UPLOAD_SYNC_APPEND => t('Append Taxonomy (if applicable) to default keywords')
        ),
        '#default_value' => isset($widget['default_keyword_sync']) ? $widget['default_keyword_sync'] : VIDEO_UPLOAD_SYNC_APPEND,
        '#required' => TRUE,
      );


      // developer tags
      $form['developer_tags'] = array(
        '#type' => 'textfield',
        '#title' => t('Developer Tags'),
        '#default_value' => $widget['developer_tags'],
        '#description' => t('Videos uploaded to YouTube can have hidden tags associated with them for later organization and tracking. Separate tags with a comma.'),
      );
      if (module_exists('token')) {
        $form['developer_tags']['#description'] .= t('<br />The following tokens can be used in <em>Developer Tags</em>');
        $form['developer_tags']['#suffix'] = theme('fieldset', array('#children' => theme('token_help', 'user'), '#collapsed' => TRUE, '#collapsible' => TRUE, '#title' => t('Tokens')));
      }

      // video category (this is a fixed list from youtube
      $form['video_category'] = array(
        '#type' => 'select',
        '#title' => t('YouTube Category'),
        '#options' => _video_upload_youtube_available_categories(),
        '#default_value' => $widget['video_category'],
        '#required' => TRUE,
        '#description' => t('YouTube requires that videos be placed into one of these categories'),
      );

      return $form;
    case 'save':
      return array(
        'video_category',
        'auto_delete_rejected_videos',
        'file_extensions',
        'use_browser_upload_method',
        'default_title',
        'default_description',
        'default_keywords',
        'developer_tags',
        'display',
        'default_title_sync',
        'default_description_sync',
        'default_keyword_sync',
      );
  }
}

/**
 * Implementation of hook_widget()
 */
function video_upload_widget($op, &$node, $field, &$items) {
  switch ($op) {
    case 'prepare form values' :
      _video_upload_widget_prepare_form_values($node, $field, $items);
      break;

    case 'process form values':
      _video_upload_widget_process_form_values($node, $field, $items);
      break;

    case 'form' :
      return _video_upload_widget_form($node, $field, $items);

    case 'validate' :
      // this doesn't work yet
      _video_upload_widget_validate($node, $field, $items);
      break;

    case 'submit' :
      break;

    case 'default value' :
      return array(
        array(
          'id' => '0',
          'status' => VIDEO_UPLOAD_STATUS_UNKNOWN,
          'status_ts' => '',
          'fid' => '',
          // @todo see other inline delete todo items
          // 'delete' => 0,
        ),
      );
      break;
  }

  return;
}

/**
 * Depending on if $node_field contains a YouTube ID or not, the form returned
 * will be drastically different.
 * @param boolean $save
 *   This is only passed when rendering the form from 
 */
function _video_upload_widget_form(&$node, $field, &$items) {
  $field_name = $field['field_name'];

  // this will be set to false if a video already exists on the field,
  // and multiple uploads aren't allowed.
  $generate_upload_form = true;

  $form[$field_name] = array(
    '#type' => 'fieldset',
    '#title' => t($field['widget']['label']),
    '#weight' => $field['widget']['weight'],
    '#description' => t('<strong>Note</strong>: Uploaded videos will not be saved until this post has been saved.'),
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
    '#tree' => TRUE,
    '#prefix' => '<div id="'. form_clean_id($field_name . '-attach-wrapper') . '" >',
    '#suffix' => '</div>',
  );

  $form[$field_name][0]['id'] = array(
    '#type' => 'hidden',
    '#value' => $items[0]['id'],
  );

  // Attempt a preview (won't show much on adding) for videos
  // that have an id, and have been confirmed
  if ($items[0]['id']) {
    if ($items[0]['status'] > VIDEO_UPLOAD_STATUS_UNKNOWN) {
      $form[$field_name][0]['preview'] = array(
        '#type' => 'markup',
        '#value' => theme('video_upload_video', $items[0]['id'], $field['widget']['display']['small_width'], $field['widget']['display']['small_height']),
        '#suffix' => t('Use the form below to replace this video with a different one.'),
      );
    }
    elseif ($items[0]['status'] === VIDEO_UPLOAD_STATUS_UNKNOWN) {
      $form[$field_name][0]['preview'] = array(
        '#type' => 'markup',
        '#value' => '<div class="messages">' . t('Video is processing...') . '</div>',
      );
    }
    // @todo make this work (see todo in form processing step for
    // some initial work

    // $form[$field_name][0]['delete'] = array(
    //   '#type' => 'checkbox',
    //   '#title' => t('Delete video ID %id from YouTube', array('%id' => $items[0]['id'])),
    // );
  }

  // include Drupal js for dynamic upload handling
  drupal_add_js('misc/progress.js');
  drupal_add_js('misc/upload.js');
  drupal_add_js(drupal_get_path('module', 'video_upload') . '/video_upload.js');

  // set form class (the jquery depends on this)
  $form['#attributes'] = array(
    'class' => 'video-upload',
    'enctype' => 'multipart/form-data',
  );

  $form[$field_name]['new'] = array(
    '#tree' => FALSE,
    '#prefix' => '<div id="' . form_clean_id($field_name .'-attach-hide') . '">',
    '#suffix' => '</div>',
    '#weight' => 100,
  );

  // youtube expects the POST variable to be named "file"
  if (!empty($field['widget']['file_extensions'])) {
    $allowed_extensions = t('<br />Allowed file types: <strong>@types</strong>', array('@types' => $field['widget']['file_extensions']));
    // format for accept attribute below, the attribute gets used
    // by video_upload.js as a regex pattern, thus the '|' separator
    $allowed_types = implode('|', array_filter(explode(' ', $field['widget']['file_extensions'])));
  }
  
  // overwrite warning
  if (!$field['multiple'] && $items[0]['id']) {
    $overwrite_warning = t('<strong>WARNING</strong>: Uploading another video will overwrite the above video (and be rejected if it is a duplicate).');

    // @todo the delete widget must work first
    // $generate_upload_form = FALSE;
  }

  
  // If the browser upload method is being used, we construct an upload form
  // to YouTube
  if ($generate_upload_form && $field['widget']['use_browser_upload_method']) {
    
    drupal_add_js(drupal_get_path('module', 'video_upload') . '/video_upload_browser.js');
    
    // authenticate to youtube
    if ($http_client = _video_upload_authenticate_youtube()) {
      
      // The following is taken and modified from
      // http://code.google.com/apis/youtube/developers_guide_php.html
      // @todo perhaps store in SESSION...perhaps not
      $yt = _video_upload_youtube($http_client);
      
      // create a Zend_Gdata_YouTube_VideoEntry
      $video = _video_upload_video_entry();
      
      // set up media group
      _video_upload_construct_media_group($yt, $video, $node, $field);
      
      $token_array = _video_upload_get_token_array($yt, $video);
      
      // Set action to YouTube @todo this will need to be done in order for
      // this to work w/o js enabled and then have the js re-construct the
      // action back to this site 
      // $form['#action'] = url($token_array['url'], 'nexturl=' . _video_upload_get_next_url());
      
      if ($token_array) {
        // Set youtube as the upload destination, which will then redirect to
        // the js callback url. The dynamic behavior is triggered by setting
        // the class to "upload"
        
        // token
        $form[$field_name]['new']['token'] = array(
          '#type' => 'hidden',
          // YouTube requires the name to be 'token'
          '#name' => 'token',
          '#value' => $token_array['token'],
        );
        // this gets changed, as YouTube redirects to the video_upload ajax
        // handler
        $ajax_form_submit_url = url($token_array['url'], 'nexturl=' . urlencode(_video_upload_get_next_url($field_name, $node)));
      }
      else {
        // can't generate upload form w/o a token
        $generate_upload_form = false;
        $auth_error = true;
        watchdog('video_upload', t('Authentication to YouTube succeeded, but failed to generate a token'), WATCHDOG_ERROR);
      }
    }
    else {
      // auth error will provide a warning
      $auth_error = true;
      $generate_upload_form = false;
    }

    if ($auth_error) {
      $form[$field_name]['holder'] = array(
        '#type' => 'markup',
        '#value' => t('Video Uploads currently unavailable. Please try back soon'),
      );
    }
  }
  elseif ($generate_upload_form) {
    // The Direct Upload method transfers the file here first

    // Submission to YouTube is handled later, send file here
    $ajax_form_submit_url = _video_upload_get_next_url($field_name, $node);

    foreach ($items as $delta => $item) {
      if ($item['fid']) {
        $form[$field_name][$delta]['fid'] = array(
          '#type' => 'hidden',
          '#value' => $item['fid'],
        );
      }
    }  
  }

  if ($generate_upload_form) {
    // Note, youtube requires that this field be called 'file', but the Drupal
    // Form API doesn't work with renaming of this field. Since Browser
    // uploads only work with js enabled, this field is renamed properly
    // client side when the user attempts a YouTube upload.
    $form[$field_name]['new'][$field_name . '_file'] = array(
      '#type' => 'file',
      '#description' =>  $overwrite_warning . $field['widget']['description'] . $allowed_extensions,
      '#title' => t('File'),
      '#tree' => FALSE,
      '#attributes' => array(
        'class' => 'video-upload-file video-upload video-upload-' . form_clean_id($field_name),
        // browsers tend not to enforce this, but some javascript can
        'accept' => $allowed_types,
      ),
    );
  }

  if ($generate_upload_form) {
    // The dynamic behavior of the form is triggered by the 'upload' and
    // 'video-upload-url' classes.
    $form[$field_name .'-attach-url'] = array(
      '#type' => 'hidden', 
      '#value' => $ajax_form_submit_url, 
      '#attributes' => array('class' => 'upload video-upload-url')
    );
  
    // button
    $form[$field_name]['new']['submit'] = array(
      '#type' => 'button',
      '#value' => t('Upload Video File'),
      '#id' => form_clean_id($field_name . '-attach-button'),
      '#attributes' => array(
      'class' => 'video-upload video-upload-submit',
      ),
    );
  }

  return $form;
}

/**
 * Get the url that youtube will redirect to
 * @param string $field_name
 * @param object $node
 * @return string
 */
function _video_upload_get_next_url($field_name, $node) {
  global $base_url;
  // the field name is passed as part of the path because the YouTube API
  // doesn't handle encoded urls, and submitting a ? in the url doesn't work
  // properly
  return url('video-upload/js/' . $field_name . '/' . $node->type, null, null, $absolute = true);
}

/**
 * Callback function for admin/settings/video_upload
 * @return
 *   Returns an array defining the admin settings form
 */
function _video_upload_admin_settings_form() {
  $form['youtube'] = array(
    '#type' => 'fieldset',
    '#title' => t('YouTube API Settings'),
  );
  $form['youtube']['video_upload_youtube_developer_key'] = array(
    '#type' => 'textfield',
    '#title' => t('Developer Key'),
    '#description' => t('A YouTube <a href="!url">Developer Key</a> is required', array('!url' => url('http://code.google.com/apis/youtube/dashboard/'))),
    '#default_value' => variable_get('video_upload_youtube_developer_key', false),
    '#required' => true,
  );
  $form['youtube']['video_upload_youtube_username'] = array(
    '#type' => 'textfield',
    '#title' => t('YouTube Username'),
    '#default_value' => variable_get('video_upload_youtube_username', false),
    '#required' => true,
  );
  $form['youtube']['video_upload_youtube_password'] = array(
    '#type' => 'textfield',
    '#title' => t('YouTube Account Password'),
    '#default_value' => variable_get('video_upload_youtube_password', false),
    '#required' => true,
  );
  return system_settings_form($form);
}

/**
 * Return a youtube url for a given id
 */
function video_upload_link_youtube($id) {
  return url(VIDEO_UPLOAD_YOUTUBE_EMBED_URL . '/' . $id);
}

/**
 * Menu callback: YouTube redirect, or in the case of direct upload method,
 * the Drupal form ajax callback
 */
function video_upload_js() {
  $status = TRUE;

  $field_name = arg(2);

  // rudimentary node object
  $node->type = arg(3);

  // load field definition
  $field = content_fields($field_name, $node->type);

  // check status
  $status = $_GET['status'];
  $id = $_GET['id'];

  if (!empty($_POST)) {
    // local request, not a redirect from YouTube, thus
    // a direct upload

    // Make node from POST data
    $node = (object)$_POST;

    $items = array();
    $values  = content_field('load', $node, $field, $items, FALSE, FALSE);
    $items = $values[$field_name];

    // any 'load' operations
    video_upload_field('load', $node, $field, $items, FALSE, FALSE);
    _video_upload_widget_prepare_form_values($node, $field, $items);
    _video_upload_widget_validate($node, $field, $items);
  }
  elseif ($id && $status == '200') {
    // success, coming from YouTube

    // fake _POST so as not to wipe-out video upload sessions
    $_POST['video_upload_fake'] = 1;

    drupal_set_message(t('Video has been uploaded, and is being processed, please continue to save this post.'));

    $items = array(
      array(
        'id' => $id,
        'status' => VIDEO_UPLOAD_STATUS_UNKNOWN,
        'status_ts' => time(),
        'fid' => 0,
      ),
    );

    $node->{$field_name}[0]['id'] = $id;
    $values = content_field('load', $node, $field, $items, FALSE, FALSE);
  }
  else {
    // failure
    drupal_set_message(t('No file uploaded'), 'error');
    $status = 2;
    // this variable will prevent any existing item from being overwritten
    $save = true;
  }

  $form = _video_upload_widget_form($node, $field, $items, $save);
  $form = form_builder('video_upload_js', $form);

  $output = theme('status_messages') . drupal_render($form);
  print drupal_to_js(array('status' => $status, 'data' => $output));
  exit;
}

/**
 * Implementation of hook_requirements()
 *
 * Checks for the existence required variable settings
 */
function video_upload_requirements($phase) {
  $requirements = array();

  // Ensure translations don't break at install time.
  $t = get_t();

  // Get GData-specific requirements
  $gdata_requirements = _video_upload_gdata_requirements($phase);

  if ($phase == 'runtime') {

    $username      = variable_get('video_upload_youtube_username', false);
    $password      = variable_get('video_upload_youtube_password', false);
    $developer_key = variable_get('video_upload_youtube_developer_key', false);

    // must have certain settings to use
    if (!$username) {
      $requirements['video_upload_username'] = array(
        'title' => $t('Video Upload: Username'),
        'value' => $t('Not Found'),
        'severity' => REQUIREMENT_ERROR,
        'description' => $t('The Video Upload module requires at least one YouTube username/password combo, which can be set <a href="!url">here</a>.', array('!url' => url('admin/settings/video-upload'))),
      );
    }
    if (!$password) {
      $requirements['video_upload_password'] = array(
        'title' => $t('Video Upload: Password'),
        'value' => $t('Not Found'),
        'severity' => REQUIREMENT_ERROR,
        'description' => $t('The Video Upload module requires at least one YouTube username/password combo, which can be set <a href="!url">here</a>.', array('!url' => url('admin/settings/video-upload'))),
      );
    }
    if (!$developer_key) {
      $requirements['video_upload_developer_key'] = array(
        'title' => $t('Video Upload: YouTube Developer Key'),
        'value' => $t('Not Found'),
        'severity' => REQUIREMENT_ERROR,
        'description' => $t('The Video Upload module requires a <a href="!devurl">YouTube Developer Key</a>, which can be set <a href="!url">here</a>.', array('!url' => url('admin/settings/video-upload'), '!devurl' => url('http://code.google.com/apis/youtube/dashboard'))),
      );
    }

    if ($username && $password && $developer_key && !_video_upload_authenticate_youtube()) {
      // failed to connect/authenticate
      $requirements['video_upload_authentication'] = array(
        'title' => $t('Video Upload: YouTube Authentication'),
        'value' => $t('Failed'),
        'severity' => REQUIREMENT_ERROR,
        'description' => $t('The Video Upload module has the required information, but was unable to authenticate to YouTube. There may be an error in one or more of the following: !list These settings can be reviewed <a href="!url">here</a>.', array('!list' => theme('item_list', array('username', 'password', 'developer key')), '!url' => url('admin/settings/video-upload'))),
      );
    }
  }

  return array_merge($requirements, $gdata_requirements);
}

/**
 * Verify that an uploaded video 
 * @todo make this work, and abstract the Zend library references out to
 *   zend_gdata.inc
 */
function video_upload_youtube_validate($id) {
  if ($http_client = _video_upload_authenticate_youtube()) {
    $yt = _video_upload_youtube($http_client);
    $status =  _video_upload_youtube_get_status_by_id($id, $yt);
    return $status;
  }
  return VIDEO_UPLOAD_STATUS_UNKNOWN;
}

/**
 * Validate a set of items
 */
function _video_upload_widget_validate(&$node, $field, &$items) {
  if ($field['required']) {
    if ($field['widget']['use_browser_upload_method']) {
      // if using the browser upload method, we need a YouTube ID
      if (!$items[0]['id']) {
        $error = true;
      }
    }
    else {
      // for the direct upload method, we need a file
      if (!$items[0]['fid']) {
        $error = true;
      }
    }
    if ($error) {
      form_set_error($field['field_name'], t('@field is required. Please select a video and hit the <em>Upload Video File</em> button.', array('@field' => $field['widget']['label'])));
    }
  }
}

/**
 * Prepare data for form
 */
function _video_upload_widget_prepare_form_values(&$node, $field, &$items) {
  $field_name = $field['field_name'];

  if (!count($_POST)) {
    // start fresh if no post datas
    video_upload_clear_session_data();
    // initialize
    $_POST[$field_name] = array();
  }

  // @fixme - This need to be reviewed. The reason this is required
  //          is that the Drupal Form API doesn't allow js to change
  //          the values of hidden variables, so it must be done here.
  //          Supposedly it is dangerous to do so, thus the need for a
  //          review.
  foreach ($_POST[$field_name] as $key => $item) {
    if ($_POST[$field_name][$key]['id']) {
      $node->{$field_name}[$key]['id'] = $_POST[$field_name][$key]['id'];
      $items[$key]['id'] = $node->{$field_name}[$key]['id'];
    }
  }

  // Check for file uploaded to local server
  if ($file = file_check_upload($field_name . '_file')) {
    $valid = _video_upload_widget_validate_video_file($node, $field, $items, $file);
    if ($valid) {
      _video_upload_upload_video_file($node, $field, $items, $file);
    }
    else {
      // @todo delete the invalid image
    }
  }
}

/**
 * Convert back to native storage
 */
function _video_upload_widget_process_form_values(&$node, $field, &$items) {
  foreach ($items as $delta => $item) {

    if ($item['id'] && !$item['status']) {
      // @todo make this work
      if (false && $item['delete'] && $item['id']) {
        // delete video from youtube
        _video_upload_delete(array($item), $field);
        $item['id'] = '';
        $item['delete'] = 0;
      }
      if ($status = video_upload_youtube_validate($item['id'], $node)) {
        $item['status'] = $status->status;
        $item['status_ts'] = time();
      }
      $items[$delta] = $item;
    }
  }
}

/**
 * Theme a video
 */
function theme_video_upload_video($yt_id, $width = '425', $height = '355', $field = array(), $params = array(), $attributes = array()) {
  if (!$yt_id) {
    return '';
  }

  $video_url = VIDEO_UPLOAD_YOUTUBE_EMBED_URL . '/' . $yt_id;

  if (!$field['widget']['display']['related_videos']) {
    // related videos
    $video_url .= '&rel=0';
  }
  if ($field['widget']['display']['autoplay']) {
    // autoplay
    $video_url .= '&autoplay=1';
  }

  $default_params = array(
    'movie' => $video_url,
    'wmode' => 'transparent',
    'bgcolor' => '#FFFFFF',
  );
  $all_params = array_merge($default_params, $params);
  foreach ($all_params as $p_name => $p_value) {
    $parameters .= '
    <param name="' . $p_name . '" value="' . $p_value .'" />
';
  }

  static $v = 1;
  $default_attributes = array(
    'type' => 'application/x-shockwave-flash',
    'height' => $height,
    'width' => $width,
    'data' => $video_url,
    'id' => 'videoEmbed' . $v,
  );
  $v ++;

  $all_attributes = array_merge($default_attributes, $attributes);

  $embed_attributes = array(
    'src' => $default_attributes['data'],
    'type' => $default_attributes['type'],
    'wmode' => 'transparent',
    'width' => $default_attributes['width'],
    'height' => $default_attributes['height'],
  );
  $embed = '<embed ' . drupal_attributes($embed_attributes) . '></embed>';

  return '
  <object ' . drupal_attributes($all_attributes) . '>'
    . $parameters . $embed . '</object>';
}

/**
 * Implementation of hook_formatter_info
 */
function video_upload_field_formatter_info() {
  return array(
    'default' => array(
      'label' => t('Default'),
      'field types' => array('video_upload'),
    ),
    'thumb' => array(
      'label' => t('Thumbnail Image'),
      'field types' => array('video_upload'),
    ),
    'thumb_link' => array(
      'label' => t('Thumbnail Image as link'),
      'field types' => array('video_upload'),
    ),
    'small' => array(
      'label' => t('Small Video'),
      'field types' => array('video_upload'),
    ),
  );
}

/**
 * Theme a thumbnail
 * @todo offer random image (YT provides 3)
 */
function theme_video_upload_video_thumb($field, $item, $node, $as_link = FALSE) {
  if (!$item['id']) {
    return '';
  }
  if (!$item['status']) {
    // if the video isn't done processing, through a flag onto the end of the
    // url so the user's browser doesn't cache the processing thumbnail
    $flag = '?f=' . rand(0,10);
  }
  $attributes = array(
    'src' => VIDEO_UPLOAD_YOUTUBE_THUMB_URL . '/' . $item['id'] . '/1.jpg' . $flag,
    'alt' => t('YouTube Thumbnail'),
  );
  $width = $field['widget']['display']['thumb_width'];
  $height = $field['widget']['display']['thumb_height'];
  if ($width) {
    $attributes['width'] = $width;
  }
  if ($height) {
    $attributes['height'] = $height;
  }
  $img = '<img ' . drupal_attributes($attributes) . '/>';
  if ($as_link && $node->nid) {
    $img = l($img, 'node/' . $node->nid, NULL, NULL, NULL, NULL, TRUE);
  }
  return $img;
}

/**
 * Implementation of hook_formatter()
 *
 * In addition to formatting, this hook is used to check the status of a
 * video, rather than wait up to an hour for cron to update the status. The
 * inline fixme explains why this would be better off elsewhere.
 */
function video_upload_field_formatter($field, $item, $formatter, $node = NULL) {
  if (!$item['status'] && $item['id'] && arg(2) != 'edit' && arg(1) != 'add') {
    // @fixme: there must be a better place than on formatting. Perhaps the
    // content 'load' hook, but so far, that hasn't worked. Where ever it
    // eventually gets done, it will still need to make sure that it doesn't
    // happen during edits, which will violate the Drupal Form API (since the
    // node will be changed during an edit, and worse, during and add, post a
    // duplicate).
    
    // attempt to verify and update status
    $status = video_upload_youtube_validate($item['id']);
    if ($status) {
      if ($status->status === VIDEO_UPLOAD_STATUS_OK) {
      }
      elseif ($status->status === VIDEO_UPLOAD_STATUS_BAD) {
        // @todo delete, or queue for delete
        $status_message = theme('video_upload_video_status_message', $item, t('Error processing video: @message', array('@message' => $status->message)));
        $status->status = VIDEO_UPLOAD_STATUS_DELETE;
        // @todo There should be a hook here to call actions that one might
        // want to do for a rejected video, such as unpublish the node, delete
        // the video from YT, etc.
      }
      // load full node
      $node = node_load(array('nid' => $node->nid));
      // save the video's status
      _video_upload_node_save_video_status($node, $field['field_name'], $status);
      
      // @todo notify the user
    }
    else {
      // tell people it isn't ready
      $status_message = theme('video_upload_video_status_message', $item);
    }
  }

  switch ($formatter) {
    case 'thumb_link' :
      $as_link = TRUE;
    case 'thumb' :
      // return a thumbnail image
      return theme('video_upload_video_thumb', $field, $item, $node, $as_link);
    case 'small' :
      return $status_message . theme('video_upload_video', $item['id'], $field['widget']['display']['small_width'], $field['widget']['display']['small_height']);
    case 'default' :
    default :
      return $status_message . theme('video_upload_video', $item['id'], $field['widget']['display']['default_width'], $field['widget']['display']['default_height']);
  }
}

/**
 * Sets a default title for uploaded video
 */
function _video_upload_set_default_title($node, $field) {
  $widget = $field['widget'];
  switch ($widget['default_title_sync']) {
    case VIDEO_UPLOAD_SYNC_APPEND :
      $title = $widget['default_title'];
      if ($node->title) {
        $title .= ': ';
      }
      // fall through to append
    case VIDEO_UPLOAD_SYNC :
      if ($node->title) {
        $title = $title . $node->title;
        break;
      }
    case VIDEO_UPLOAD_SYNC_NONE :
    default :
      $title = $field['widget']['default_title'] 
        ? $field['widget']['default_title'] 
        : t('Video from @site_name', array('@site_name' => variable_get('site_name', 'Drupal')));

      if (module_exists('token')) {
        global $user;
        $title = token_replace($title, 'user', $user);
      }
  }

  // Can't be blank
  if (!trim($title)) {
    $title = t('Placeholder Title');
  }

  // 60 is the max length on YouTube
  $title = substr($title, 0, 60); 
  return $title;
}

/**
 * Sets a default description for uploaded video
 * @todo: site admins need to have more control over this (eg, some may
 *        prefer that the site description goes up with the video, rather than
 *        user-entered data
 */
function _video_upload_set_default_description($node, $field) {
  $widget = $field['widget'];

  // Set description to teaser
  switch ($widget['default_description_sync']) {
    case VIDEO_UPLOAD_SYNC_APPEND :
      $description = $widget['default_description'] . "\n\n";
      // fall through to add teaser
    case VIDEO_UPLOAD_SYNC :
      if ($node->teaser) {
        $description = $description . $node->teaser;
        break;
      }
      // otherwise, fall through
    case VIDEO_UPLOAD_SYNC_NONE :
      $description = $widget['default_description'];

  }

  if (module_exists('token')) {
    global $user;
    $description = token_replace($description, 'user', $user);
    $description = token_replace($description, 'node', $node);
  }

  if (!trim($description)) {
    $description = t('Video uploaded from @site_name : @site_slogan', array('@site_name' => variable_get('site_name', 'Drupal'), '@site_slogan' => variable_get('site_slogan', false)));
  }

  if (module_exists('token')) {
    global $user;
    $description = token_replace($description, 'user', $user);
  }
  return $description;
}

/**
 * Sets developer tags
 * @return array
 */
function _video_upload_set_developer_tags($node, $field) {
  if ($field['widget']['developer_tags']) {
    $tags = explode(',', $field['widget']['developer_tags']);
  }
  else {
    return array(substr(str_replace(array(',', ' '), '', trim(variable_get('site_name', 'Drupal'))), 0, 25));
  }

  if (module_exists('token')) {
    global $user;
    foreach ($tags as $key => $tag) {
      // there seems to be an invisible 26 character limit
      $tags[$key] = substr(str_replace(array(',', ' '), '', trim(check_plain(token_replace($tag, 'user', $user)))), 0, 25);
    }
  }

  // add field name as a tag
  if (!in_array($field['field_name'], $tags)) {
    $tags[] = $field['field_name'];
  }

  return $tags;
}

/**
 * Gets the YouTube category
 * Defaults to entertainment, since this is a required item by youtube
 */
function _video_upload_get_video_category($node, $field) {
  return $field['widget']['video_category'] ? $field['widget']['video_category'] : 'Entertainment';
}

/**
 * Set keywords by attempting to use taxonomy
 * @return string
 */
function _video_upload_get_video_keywords($node, $field) {
  $widget = $field['widget'];

  $video_taxonomy = _video_upload_get_formatted_taxonomy($node);

  switch ($widget['default_keyword_sync']) {
    case VIDEO_UPLOAD_SYNC_APPEND :
      $keywords = $widget['default_keywords'];
      if ($video_taxonomy) {
        $keywords .= ', ';
      }
      // fall-through to add taxonomy
    case VIDEO_UPLOAD_SYNC :
      $keywords = $keywords . $video_taxonomy;
      break;
    case VIDEO_UPLOAD_SYNC_NONE :
    default :
      $keywords = $widget['default_keywords'];
  }

  return $keywords;
}

/**
 * List of available youtube categories
 * @todo pull automatically and cache using
 *   VIDEO_UPLOAD_GDATA_CATEGORIES_SCHEME
 */
function _video_upload_youtube_available_categories() {
  $categories = array(
    'Film',
    'Autos',
    'Music',
    'Animals',
    'Sports',
    'Travel',
    'Shortmov',
    'Videoblog',
    'Games',
    'Comedy',
    'People',
    'News',
    'Entertainment',
    'Education',
    'Howto',
    'Nonprofit',
    'Tech',
  );
  // must have a keyed array so the actual value gets stored instead of just
  // the numeric key
  return array_combine($categories, $categories);
}

/**
 * Theme a specific video upload status message
 * @fixme
 *   This function should be integrated with theme_video_upload_status_text(),
 *   as they do nearly the same thing in slightly different ways
 */
function theme_video_upload_video_status_message($item, $message = null) {
  if (!$message) {
    $message = t('Video hasn\'t finished processing yet');
  }
  return '<div class="messages">' . $message . '</div>';
}

/**
 * GData Wrapper Functions
 */

/**
 * YouTube Authentication
 */
function _video_upload_authenticate_youtube() {
  return _video_upload_gdata_authenticate_youtube();
}

/**
 * YouTube/GData Object
 * @param $http_client
 *   object|boolean http_client. If passed as TRUE, the http_client will be
 *   generated
 */
function _video_upload_youtube($http_client = null) {
  if ($http_client === TRUE) {
    // get new http authentication
    $http_client = _video_upload_authenticate_youtube();
  }
  return _video_upload_gdata_youtube($http_client);
}

/**
 * Video Entry
 */
function _video_upload_video_entry() {
  return _video_upload_gdata_video_entry();
}

/**
 * Media Group contains the title, developer tags, YouTube category and
 * keywords.
 */
function _video_upload_construct_media_group(&$yt, &$video, $node, $field) {
  return _video_upload_gdata_construct_media_group($yt, $video, $node, $field);
}

/**
 * YouTube Token Array
 * @return array
 */
function _video_upload_get_token_array($yt, $video) {
  return _video_upload_gdata_get_token_array($yt, $video);
}

/**
 * Implementation of hook_cron()
 * @fixme make this work properly once a field has been reused in another
 *   content type
 */
function video_upload_cron() {
  // find types containing video_upload field
  $res = db_query("SELECT type_name, field_name FROM {node_field_instance} LEFT JOIN {node_field} USING (field_name) WHERE type = '%s'", 'video_upload');
  while ($a = db_fetch_object($res)) {
    // verify videos
    _video_upload_verify_all($a->type_name, $a->field_name);
    // delete videos queued for deletion
    _video_upload_delete_rejected_videos($a->type_name, $a->field_name);
    // update YouTube info for all flagged videos
    _video_upload_update_all_videos($a->type_name, $a->field_name);
  }
}

/**
 * Cycle through all records in a table with status of 0 and attempt to verify
 * them on YouTube. Once verified, also attempt to update title/tags on
 * YouTube
 */
function _video_upload_verify_all($type, $field_name) {
  // @fixme this, specifically, is where the problem arrises once a field has
  //   been reused in another content type. It should be abstracted to use the
  //   cck api to gather this information.
  $res = db_query("SELECT * FROM {content_type_%s} WHERE %s_status = %d and %s_id <> ''", $type, $field_name, VIDEO_UPLOAD_STATUS_UNKNOWN, $field_name);

  if (db_num_rows($res)) {

    // get YouTube connection
    $yt = _video_upload_youtube(TRUE);

    // get a feed of all the user's videos (!!) 
    // @fixme unfortunately, this is currently the only way to check on videos
    //        that are not yet published.  A much more efficient and sane
    //        method would be to only look up the videos on which we don't
    //        have a status
    $feed = _video_upload_gdata_get_feed(VIDEO_UPLOAD_YOUTUBE_DEFAULT_USER_FEED, $yt);

    if ($feed) {
      while ($a = db_fetch_object($res)) {
        $yt_id = $a->{$field_name . '_id'};
        $video_ids[] = $yt_id;
        $videos[$yt_id] = $a;
      }

      foreach ($feed as $video) {
        if (!in_array($video->getVideoId(), $video_ids)) {
          // this isn't in the list of videos we currently care to check
          continue;
        }

        $status = _video_upload_gdata_get_video_status($video);

        if ($status->status === false) {
          // the video is bad, the node should be deleted, or unpublished, or
          // perhaps the user should be notified Setting status to -1 queues
          // the video for deletion
          $status->status = VIDEO_UPLOAD_STATUS_DELETE;
          // load full node
          $node = node_load(array('nid' => $videos[$video->getVideoId()]->nid));
          _video_upload_node_save_video_status($node, $field_name, $status);
        }
        elseif ($status->status === true) {
          // the video is good, update the table
          $node = node_load(array('nid' => $videos[$video->getVideoId()]->nid));
          // update YouTube if applicable
          _video_upload_update_video_remote($yt, $video, $node, $field_name, $status);

          // the video is good, update the table.
          _video_upload_node_save_video_status($node, $field_name, $status);
          // @todo notify the author
        }
        else {
          // nothing found on the video, wait until next time
        }
      } 
    }
  }
}

/**
 * Cycle through all records in a table with status of 1 and update info on
 * YouTube
 */
function _video_upload_update_all_videos($type, $field_name) {
  $res = db_query("SELECT * FROM {content_type_%s} WHERE %s_status = %d and %s_id <> ''", $type, $field_name, VIDEO_UPLOAD_STATUS_OK, $field_name);
  if (db_num_rows($res)) {
    // get YouTube connection
    $yt = _video_upload_youtube(TRUE);

    // get a feed of all the user's videos (!!) 
    // @fixme unfortunately, this is currently the only way to check on videos
    //        that are not yet published.  A much more efficient and sane
    //        method would be to only look up the videos on which we don't
    //        have a status
    $feed = _video_upload_gdata_get_feed(VIDEO_UPLOAD_YOUTUBE_DEFAULT_USER_FEED, $yt);

    if ($feed) {
      while ($a = db_fetch_object($res)) {
        $yt_id = $a->{$field_name . '_id'};
        $video_ids[] = $yt_id;
        $videos[$yt_id] = $a;
      }
    }

    foreach ($feed as $video) {
      if (!in_array($video->getVideoId(), $video_ids)) {
        continue;
      }
      // load the node in question
      $node = node_load(array('nid' => $videos[$video->getVideoId()]->nid));
      $status = new stdClass();
      _video_upload_update_video_remote($yt, $video, $node, $field_name, $status);
      // the video may have been updated, thus the status may have changed
      _video_upload_node_save_video_status($node, $field_name, $status);
    }
  }
}

/**
 * Cycle through all records in a table with status of -1 and delete them if
 * the field is configured to do so.
 */
function _video_upload_delete_rejected_videos($type, $field_name) {
  // get field definition
  $type_def = content_types($type);
  $field = $type_def['fields'][$field_name];

  if ($field['widget']['auto_delete_rejected_videos']) {

    $res = db_query("SELECT * FROM {content_type_%s} WHERE %s_status = %d and %s_id <> ''", $type, $field_name, VIDEO_UPLOAD_STATUS_DELETE, $field_name);

    if (db_num_rows($res)) {

      // get YouTube connection
      $yt = _video_upload_youtube(TRUE);

      // get a feed of all the user's videos (!) 
      // @fixme unfortunately, this is currently the only way to check on
      //        videos that are not yet published.  A much more efficient and
      //        sane method would be to only look up the videos on which we
      //        don't have a status
      $feed = _video_upload_gdata_get_feed(VIDEO_UPLOAD_YOUTUBE_DEFAULT_USER_FEED, $yt);

      if ($feed) {
        while ($a = db_fetch_object($res)) {
          $yt_id = $a->{$field_name . '_id'};
          $video_ids[] = $yt_id;
          $videos[$yt_id] = $a;
        }

        foreach ($feed as $video) {
          if (!in_array($video->getVideoId(), $video_ids)) {
            continue;
          }
          // delete the video from YouTube
          $node = node_load(array('nid' => $videos[$video->getVideoId()]->nid));
          _video_upload_delete_video_remote($yt, $video, $node, $field_name);
        }
      }
    }
  }
}

/**
 * Validate a video file uploaded to the localhost
 */
function _video_upload_widget_validate_video_file($node, $field, $items, $file) {
  // @todo make it validate
  return true;
}

/**
 * Upload a file, and track in $_SESSION
 *
 * Note, saving the file and queueing it for processing are done once the node
 * is saved.
 */
function _video_upload_upload_video_file(&$node, $field, &$items, $file) {
  $key = 'upload_'. count($_SESSION['video_upload']['files']);
  $file->fid = $key;
  $file->source = $key;
  $_SESSION['video_upload']['files'][$file->fid] = $file;
  $items[0]['fid'] = $file->fid;
}

/**
 * Clear video upload session data
 */
function video_upload_clear_session_data() {
  // @todo: Session handling for direct upload method isn't complete yet
  return;
  if (is_array($_SESSION['video_upload']['files'])) {
    foreach ($_SESSION['video_upload']['files'] as $fid => $file) {
      file_delete($file->filepath);
    }
    unset($_SESSION['video_upload']);
  }
}

/**
 * Set the video status fields on a node
 * @fixme this needs to be re-worked for multiple videos per field
 */
function _video_upload_node_set_video_status(&$node, $field_name, $status) {
  $node->{$field_name}[0]['status'] = $status->status;
  $node->{$field_name}[0]['status_ts'] = time();
}

/**
 * Prepare and save a node, perhaps changing the video status. This wrapper
 * function does all the necessary CCK operations to ensure node integrity.
 */
function _video_upload_node_save_video_status(&$node, $field_name, $status) {
  // invoke prepare form values op on hook_widget()
  _content_widget_invoke('prepare form values', $node);
  _video_upload_node_set_video_status($node, $field_name, $status);
  node_save($node);
}

/**
 * Syncronize YouTube fields with node
 *  - title
 *  - keywords
 *  - description
 */
function _video_upload_update_video_remote($yt, $video, &$node, $field_name, &$status) {
  $update = false;
  // need widget
  $field = content_fields($field_name, $node->type);
  $widget = $field['widget'];

  $title = _video_upload_set_default_title($node, $field);
  if ($video->getVideoTitle() != $title) {
    // set video title
    $video->mediaGroup->title->text = $title;
    $update = true;
  }

  // Set keywords based on taxonomy
  $keywords = _video_upload_get_video_keywords($node, $field);
  if ($video->mediaGroup->getKeywords()->getText() != $keywords) {
    $video->mediaGroup->keywords->text = $keywords;
    $update = true;
  }

  $description = _video_upload_set_default_description($node, $field);
  if ($video->getVideoDescription() != $description) {
    $video->mediaGroup->description->text = $description;
    $update = true;
  }

  if ($update) {
    // the video has been updated, send changes to YouTube
    if (_video_upload_gdata_update_video($yt, $video)) {
      // set status to 2 to indicate an update has occurred
      $status->status = VIDEO_UPLOAD_STATUS_OK_SYNCED;
    }
  }
}

/**
 * Remove a video from YouTube
 */
function _video_upload_delete_video_remote($yt, $video, &$node, $field_name) {
  $result = _video_upload_gdata_delete_video($yt, $video);
}


/**
 * Get taxonomy terms associated with node
 * @return string formatted for YouTube keywords or boolean false
 */
function _video_upload_get_formatted_taxonomy($node) {
  $video_taxonomy = array();

  if (!$node->taxonomy) {
    return false;
  }

  foreach ($node->taxonomy as $tid => $term) {
    // no white spaces allowed in keywords, and each keyword is limited to 25
    // characters in length
    $video_taxonomy[] = substr(str_replace(' ', '-', trim($term->name)), 0, 25);
  }

  if (empty($video_taxonomy)) {
    return false;
  }

  return implode(', ', $video_taxonomy);
}

/**
 * Get the status of a video by id
 */
function _video_upload_youtube_get_status_by_id($id, $yt) {
  if ($video = _video_upload_get_video_object_by_id($id, $yt)) {
    // the video of interest, should ususally be near the top of the feed
    $status = _video_upload_gdata_get_video_status($video);

    // translate from gdata value to video upload values
    if ($status->status === TRUE) {
      $status->status = VIDEO_UPLOAD_STATUS_OK;
    }
    elseif ($status->status === FALSE) {
      $status->status = VIDEO_UPLOAD_STATUS_BAD;
    }

    return $status;
  }
  return;
}

/**
 * Get a YouTube video object by id
 * @todo Once YouTube API offers a way to do this without looping through the
 *       entire feed, this can be optimized
 */
function _video_upload_get_video_object_by_id($id, $yt) {
  // get feed of all videos
  $feed = _video_upload_gdata_get_feed(VIDEO_UPLOAD_YOUTUBE_DEFAULT_USER_FEED, $yt);
  if ($feed) {
    foreach ($feed as $video) {
      if ($video->getVideoId() == $id) {
        return $video;
      }
    }
  }
}

/**
 * Remove video from YouTube on delete of node
 */
function _video_upload_delete($items, $field) {
  $yt = _video_upload_youtube(TRUE);
  foreach ($items as $item) {
    if ($item['id'] && $video = _video_upload_get_video_object_by_id($item['id'], $yt)) {
      _video_upload_delete_video_remote($yt, $video);
    }
  }
}

/**
 * Menu callback: administer video
 */
function video_upload_admin_video() {
  if ($_POST['operation'] == 'delete' && $_POST['videos']) {
    return drupal_get_form('video_upload_admin_video_delete_confirm');
  }
  $output = drupal_get_form('video_upload_admin_video_form');
  return $output;
}

/**
 * Video deletion confirmation
 */
function video_upload_admin_video_delete_confirm() {
  $edit = $_POST;

  $form['videos'] = array(
    '#prefix' => '<ul>', 
    '#suffix' => '</ul>', 
    '#tree' => TRUE
  );

  // array_filter returns only elements with TRUE values
  foreach (array_filter($edit['videos']) as $vid => $value) {
    $form['videos'][$vid] = array(
      '#type' => 'hidden',
      '#value' => 'delete',
      '#prefix' => '<li>',
      '#suffix' => check_plain($edit['vtitle-' . $vid]) . '</li>' . "\n",
    );
  }
  $form['operation'] = array('#type' => 'hidden', '#value' => 'delete');

  return confirm_form(
    $form,
    t('Are you sure you want to delete these videos?'),
    'admin/content/video-upload', t('This action cannot be undone.'),
    t('Delete all'), t('Cancel')
  );
}

/**
 * Delete videos after confirmation
 */
function video_upload_admin_video_delete_confirm_submit($form_id, $form_values) {
  if ($form_values['confirm']) {
    $yt = _video_upload_youtube(TRUE);
    foreach ($form_values['videos'] as $vid => $value) {
      $video = _video_upload_get_video_object_by_id($vid, $yt);
      if ($video) {
        drupal_set_message(t('Video %id has been removed from YouTube', array('%id' => $vid)));
        _video_upload_delete_video_remote($yt, $video);
      }
    }
    drupal_set_message(t('The videos have been deleted'));
  }

  return 'admin/content/video-upload';
}

/**
 * Process video admin form
 */
function video_upload_admin_video_form_submit($form_id, $form_values) {
}

/**
 * Video administration form

 * @todo Replace these queries with calls to the cck api, or similar, since
 * they currently break once a field has been reused in another type.
 */
function video_upload_admin_video_form() {
  // get YouTube connection
  $yt = _video_upload_youtube(TRUE);

  // get feed of all videos
  $feed = _video_upload_gdata_get_feed(VIDEO_UPLOAD_YOUTUBE_DEFAULT_USER_FEED, $yt);

  // get list of all types using a video upload field
  $res = db_query("SELECT type_name, field_name FROM {node_field_instance} LEFT JOIN {node_field} USING (field_name) WHERE type = '%s'", 'video_upload');

  // gather a list of ids
  $all_videos = array();
  while ($type = db_fetch_object($res)) {
    // build a query for each type
    // first, see if field is in content table, or in a field table
    $video_id_res = db_query("SELECT %s_id AS ytid, nid FROM {content_type_%s} WHERE %s_id IS NOT NULL AND %s_id <> ''", $type->field_name, $type->type_name, $type->field_name, $type->field_name);
    while ($id = db_fetch_object($video_id_res)) {
      // add field_name
      $id->field_name = $type->field_name;
      $all_videos[$id->ytid] = $id;
    }
  }

  $video_ids = array_keys($all_videos);

  // the big feed list will be a combination of gdata objects and node objects
  // (in the event of orphaned nodes)
  $big_feed_list = $video_ids_youtube = array();

  // now, with a list of ids, loop through the feed looking for
  // isolated/stranded videos that have a developer tag set by one of our
  // fields
  foreach ($feed as $video) {
    $id = $video->getVideoId();

    // add id to the youtube ids (this is to find orphaned nodes later on)
    $video_ids_youtube[] = $id;

    $big_feed_list[] = $video;
  }

  // now, loop through drupal videos to find video ids not on youtube
  foreach ($all_videos as $id => $video) {
    if (!in_array($id, $video_ids_youtube)) {
      $node = node_load(array('nid' => $video->nid));
      $video->title = $node->title;
      $video->link = l($node->title, 'node/' . $node->nid);
      $big_feed_list[] = $video;
    }
  }

  // loop through combined list of feed video and orphaned video
  foreach ($big_feed_list as $video) {
    if (!_video_upload_is_zend_object($video)) {
      // Due to the strict OO nature of the Zend client library, we must use
      // this function instead of a simple boolean check
      $id = $video->ytid;
    }
    else {
      $id = $video->getVideoId();

      // set video title
      $video->title = check_plain($video->getVideoTitle());
      // set link
      $video->link = l($id, video_upload_link_youtube($id));
    }

    $form['id'][$id] = array(
      '#value' => $video->link,
    );

    $form['title'][$id] = array(
      '#value' => $video->title,
    );

    $form['vtitle'][$id] = array(
      '#name' => 'vtitle-' . $id,
      '#type' => 'hidden',
      '#value' => $video->title,
    );

    $node = false;
    if (in_array($id, $video_ids)) {
      // this video is associated with a node, so we can fetch the node to
      // determine the status
      $nid = $all_videos[$id]->nid;

      $node = node_load(array('nid' => $nid));

      $form['node'][$id] = array('#value' => l($nid, 'node/' . $nid));

      $field_name = $all_videos[$id]->field_name;
      $form['field_name'][$id] = array('#value' => l($field_name, 'admin/content/types/' . $node->type . '/fields/' . $field_name));
    }
    else {
      // Orphaned video, so we can operate on it. Videos associated with nodes
      // must be operated on through the node system.
      $videos[$id] = '';

      $form['node'][$key] = FALSE;
      $form['field_name'][$key] = FALSE;
    }

    // if the node has the status, display that
    $status = VIDEO_UPLOAD_STATUS_UNKNOWN;
    if ($node) {
      $status = $node->{$all_videos[$id]->field_name}[0]['status'];
    }
    if(_video_upload_is_zend_object($video) && $status < VIDEO_UPLOAD_STATUS_OK) {
      // find status from YouTube since it either hasn't been checked,
      // or this is an orphaned node
      $status = _video_upload_youtube_get_status_by_id($id, $yt);
    }
    elseif (!_video_upload_is_zend_object($video)) {
      $status = VIDEO_UPLOAD_STATUS_ORPHANED;
    }
    $status_text = theme('video_upload_status_text', $status);
    $form['status'][$id] = array('#value' => $status_text);
  }

  // this constructs the checkboxes, and in fact, the only interactivity
  // currently available. If there aren't any orphaned videos, there's nothing
  // to do.
  if (!empty($videos)) {
    $form['videos'] = array(
      '#type' => 'checkboxes',
      '#options' => $videos,
    );

    $form['options'] = array(
      '#type' => 'fieldset',
      '#title' => t('Video management options'),
      '#prefix' => '<div class="container-inline">',
      '#suffix' => '</div>',
    );
    $options = array('delete' => t('Delete selected videos'));
    $form['options']['operation'] = array(
      '#type' => 'select', 
      '#options' => $options,  
      '#default_value' => 'approve');
    $form['options']['submit'] = array(
      '#type' => 'submit', 
      '#value' => t('Submit'));
  }

  $form['pager'] = array('#value' => theme('pager', NULL, 50, 0));

  return $form;
}

/**
 * Theme the video upload admin form into a table/grid
 */
function theme_video_upload_admin_video_form($form) {
  // add css for this table
  drupal_add_css(drupal_get_path('module', 'video_upload') . '/video_upload_admin.css');

  // Overview table:
  $select_all = $form['videos'] ? theme('table_select_header_cell') : array();
  $header = array($select_all, t('Title'), t('Id'), t('Node'), t('Field Info'), t('Status'));

  // Options
  $output .= drupal_render($form['options']);

  if (isset($form['id']) && is_array($form['id'])) {
    foreach (element_children($form['id']) as $key) {
      $row = array();
      // checkbox
      $row[] = drupal_render($form['videos'][$key]);
      // video title
      $row[] = drupal_render($form['title'][$key]);
      // video id
      $row[] = drupal_render($form['id'][$key]);
      // link to node, if available
      $row[] = $form['node'][$key] ? drupal_render($form['node'][$key]) : t('orphaned');
      // field info, if available
      $row[] = $form['field_name'][$key] ? drupal_render($form['field_name'][$key]) : t('n/a');
      // video status
      $row[] = drupal_render($form['status'][$key]);
      // highlight orphaned videos
      $class =  $form['node'][$key] ? '' : 'video-upload-orphaned';
      $rows[] = array('data' => $row, 'class' => $class);
    }
  }
  else  {
    $rows[] = array(array('data' => t('No videos have been uploaded to this account'), 'colspan' => '6'));
  }

  $output .= theme('table', $header, $rows);
  if ($form['pager']['#value']) {
    $output .= drupal_render($form['pager']);
  }

  $output .= drupal_render($form);

  return '<div class="video-upload-admin">' . $output . '</div>';

}
/**
 * @return string the proper url for searching on a specific developer tag
 *   also, this currently isn't much use since it won't find the rejected
 *   videos
 */
function _video_upload_get_developer_tag_feed_url($tag) {
  // note, the youtube api fails if urls are encoded with drupal_urlencode
  $url = VIDEO_UPLOAD_YOUTUBE_FEED_BASE . '/-/' . urlencode('{' . VIDEO_UPLOAD_GDATA_DEVELOPER_TAG_SCHEME . '}' . $tag);
  return $url;
}

/**
 * Theme the video status text
 * @param mixed $status
 *   A status object or integer
 */
function theme_video_upload_status_text($status) {
  if (is_object($status)) {
    $stat = $status->status;
  }
  else {
    $stat = $status;
  }

  $class = 'video-upload-status';
  switch ($stat) {
    case VIDEO_UPLOAD_STATUS_ORPHANED :
      $status_text = t('Video removed from YouTube');
      $class .= ' video-upload-status-bad';
      break;
    case VIDEO_UPLOAD_STATUS_BAD :
      $status_text = $status->message ? $status->message : t('Unknown Error');
      $class .= ' video-upload-status-bad';
      break;
    case VIDEO_UPLOAD_STATUS_OK :
      $status_text = t('OK');
      $class .= ' video-upload-status-ok';
      break;
    case VIDEO_UPLOAD_STATUS_OK_SYNCED :
      $status_text = t('Video up-to-date');
      $class .= ' video-upload-status-ok-synced';
      break;
    case VIDEO_UPLOAD_STATUS_DELETE :
      $status_text = t('Video is bad and queued for deletion');
      $class .= ' video-upload-status-delete';
      break;
    case VIDEO_UPLOAD_STATUS_UNKNOWN :
    default :
      $status_text = t('n/a');
      $class .= ' video-upload-status-unknown';
  }

  $attributes = array(
    'class' => $class,
  );

  return '<span' . drupal_attributes($attributes) . '>' . $status_text . '</span>';
}
